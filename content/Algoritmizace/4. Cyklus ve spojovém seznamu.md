Na vstupu je **linked list** (spojovÃ½ seznam). TvÃ½m Ãºkolem je zjistit, zda se v nÄ›m nachÃ¡zÃ­ **cyklus** (nÄ›kterÃ½ z nodÅ¯ mÃ­Å™Ã­ na pÅ™edchozÃ­ node).

Linked list **bez cyklu**
```mermaid
flowchart LR
    node1((0)) -->
    node2((1)) -->
    node3((2)) --> 
    node4((3)) --> 
    node5((4))
  
```

Linked list **s cyklem**
```mermaid
flowchart LR
    node1((0)) -->
    node2((1)) -->
    node3((2)) --> 
    node4((3)) --> 
    node5((4)) --> node3
  
```

Detaily:
- Pokud obsahuje **pouze jeden prvek**, nenÃ­ v nÄ›m cyklus
- Pokud neobsahuje **Å¾Ã¡dnÃ½ prvek**, nenÃ­ v nÄ›m cyklus
  
```typescript
class ListNode {
    val: number
    next: ListNode | null
    constructor(val?: number, next?: ListNode | null) {
        this.val = (val === undefined ? 0 : val)
        this.next = (next === undefined ? null : next)
    }
}

function hasCycle(head: ListNode | null): boolean {
    // DoplÅˆ tÄ›lo funkce
};
```

> [!abstract] Testy - sprÃ¡vnÃ©ho chovÃ¡nÃ­
> ```typescript
> describe("Is linked list circular", () => {
>     test("Without cycle", () => {
>         const node1 = new ListNode(2);
>         const node2 = new ListNode(2, node1);
>         const node3 = new ListNode(3, node2);
>         const node4 = new ListNode(4, node3);
>         const head = new ListNode(5, node4);
> 
>         expect(hasCycle(head)).toStrictEqual(false);
>     });
> 
>     test("With a cycle back to start", () => {
>         const node1 = new ListNode(2);
>         const node2 = new ListNode(2, node1);
>         const node3 = new ListNode(3, node2);
>         const node4 = new ListNode(4, node3);
>         const head = new ListNode(5, node4);
> 
>         // Cycle
>         node1.next = head;
> 
>         expect(hasCycle(head)).toStrictEqual(true);
>     });
> });
> ```

Pokud nevÃ­Å¡, jak na **optimÃ¡lnÃ­ Å™eÅ¡enÃ­**, tak to zkus vyÅ™eÅ¡it **jakÃ½mkoli zpÅ¯sobem**. Potom si pÅ™eÄti, jak funguje optimÃ¡lnÃ­ algoritmus a zkus ho naprogramovat.

> [!question]- NÃ¡povÄ›da - naivnÃ­ algoritmus
> Tento algoritmus nenÃ­ **optimÃ¡lnÃ­** (mÃ¡ vysokou **pamÄ›Å¥ovou nÃ¡roÄnost**), ale je funkÄnÃ­.
> 
> ProchÃ¡zej linked list a ke kaÅ¾dÃ©mu nodu si uloÅ¾, zda uÅ¾ **byl navÅ¡tÃ­ven**.
> 
> KdyÅ¾ narazÃ­Å¡ na uÅ¾ **navÅ¡tÃ­venÃ½ node**, mÃ¡ cyklus.
> 
> KdyÅ¾ **dojdeÅ¡ na konec** (dalÅ¡Ã­ node je `null`), nemÃ¡ cyklus.

> [!question]- Å˜eÅ¡enÃ­ - naivnÃ­ algoritmus
> ```typescript
> // Naive solution - high memory footprint
> export const hasCycle = (head: ListNode | null): boolean => {
>     const set = new Set<ListNode\>();
>     let currentNode: ListNode | null = head;
> 
>     while (currentNode) {
>         if (set.has(currentNode)) return true;
> 
>         set.add(currentNode);
>         currentNode = currentNode?.next;
>     }
> 
>     return false;
> };
> ```

> [!tip]- NÃ¡povÄ›da - optimÃ¡lnÃ­ algoritmus
> Algoritmus se jmenuje "Floyd's tortoise ğŸ¢ and hare ğŸ‡ algorithm"
> 
> MÃ¡Å¡ **dva pointery**. Jeden pomalej ğŸ¢ a druhej rychlej ğŸ‡
> 
> Pomalej pointer ğŸ¢ zaÄne na **zaÄÃ¡tku** spojovÃ©ho seznamu.
> Rychlej pointer ğŸ‡ zaÄne na **zaÄÃ¡tku + 1** spojovÃ©ho seznamu.
> 
> Pomalej pointer ğŸ¢ vÅ¾dy **postupuje o jeden** node.
> Rychlej pointer ğŸ‡ vÅ¾dy **postupuje o dva** nody.
> 
> Pokud se nÄ›kdy tyto pointery **potkajÃ­** (rovnajÃ­ se), list **mÃ¡ cyklus**.
> 
> Pokud rychlej pointer ğŸ‡ **narazÃ­ na konec** listu, **nemÃ¡ cyklus**.
> 
> ProÄ to funguje? ğŸ¤”
> 
> Pokud je v listu cyklus, rychlej pointer ğŸ‡ pÅ™edbÄ›hne a eventuelnÄ› dobÄ›hne ten pomalej ğŸ¢ a budou se rovnat.
> 
> TODO: UdÄ›lat/najÃ­t nÄ›jakou hezkou vizualizaci

> [!tip]- Å˜eÅ¡enÃ­ - optimÃ¡lnÃ­ algoritmus
> ```typescript
> // Floyd's tortoise and hare algorithm
> export const hasCycle = (head: ListNode | null): boolean => {
>     let slowPointer = head;
>     let fastPointer = head?.next;
> 
>     while (fastPointer && slowPointer) {
>         slowPointer = slowPointer?.next;
>         fastPointer = fastPointer?.next?.next;
> 
>         if (slowPointer === fastPointer) return true;
>     }
> 
>     return false;
> };
> ```